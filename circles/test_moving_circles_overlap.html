<html>

<head>
  <script src="..\lib\canvas.js"></script>
  <script src="..\lib\calc.js"></script>
  <script src="..\lib\const.js"></script>
  <script src="..\lib\primitives.js"></script>
  <script src="..\lib\shapes.js"></script>
  <script src="..\lib\MouseTouchTracker.js"></script>

  <script src="..\lib\test\ut_Angles.js"></script>
  <script src="..\lib\test\ut_Calc.js"></script>
  <script src="..\lib\test\ut_Shapes.js"></script>
</head>

<body onLoad="draw()">

  <div>
    Debug
    <input type="checkbox" id="debugMode" checked>
    <!-- <label for="debugMode">Debug</label> -->
    Number of circles
    <input type="number" id="countCircle" min="2" max="120" step="10" value="0">
  </div>

  <script>
    var debugMode = document.querySelector('input[id="debugMode"]');
    debugMode.addEventListener('change', () => {
      DEBUG_RENDER = debugMode.checked;
    })
    var countCircles = 2;
    var numCircles = document.querySelector('input[id="countCircle"]');
    numCircles.value = countCircles;
    numCircles.addEventListener('change', () => {
      countCircles = parseInt(numCircles.value);
      init();
    })
  </script>

  <canvas id="canvas" style="border: 1px solid" width="600" height="600"></canvas>

  <script>
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var startX = 0;
    var startY = 0;
    var cclCmbs;

    function init() {
      cclCmbs = [];
      // for (var i = 0; i < countCircles; i++) {
      //   var x = Math.floor(Math.random() * canvas.clientWidth);
      //   var y = Math.floor(Math.random() * canvas.clientHeight);
      //   var r = Math.floor(20 + Math.random() * 80);
      // cclCmb1 = new CircleCombo(x, y, r);
      // cclCmbs.push(cclCmb1);
      // }
      cc = new CircleCombo(155, 155, 95);
      cc.render(ctx, 1);
      cclCmbs.push(cc);
      cc = new CircleCombo(215, 215, 115);
      cc.render(ctx, 1, '#FFAAFF');
      cclCmbs.push(cc);
    }

    init();

    function draw() {
      clearAll(ctx);
      grid(ctx);
      ctx.save();

      ctx.beginPath();
      ctx.moveTo(150, 50);
      ctx.lineTo(550, 50);
      ctx.lineTo(550, 400);
      ctx.lineTo(400, 550);
      ctx.lineTo(50, 550);
      ctx.lineTo(50, 150);
      ctx.arc(150, 150, 100, PI, 3 * PI / 2);

      ctx.moveTo(250, 250);
      ctx.lineTo(350, 250);
      ctx.lineTo(300, 150);
      ctx.lineTo(250, 250);

      ctx.moveTo(250, 500);
      ctx.arc(200, 500, 50, 0, DVA_PI, true);

      ctx.moveTo(400, 500);
      ctx.arc(350, 500, 50, 0, DVA_PI, false);

      var arcs = [];
      for (var i = 0; i < cclCmbs.length; i++) {
        var angles = [];
        var points = [];
        for (var j = 0; j < cclCmbs.length; j++) {
          if (i != j) {
            [ang_cclCmb1_1, ang_cclCmb1_2] = Calc.circleOverlap(cclCmbs[i], cclCmbs[j]);
            angles.push([ang_cclCmb1_1, ang_cclCmb1_2]);
            points.push(ang_cclCmb1_1.begin);
            points.push(ang_cclCmb1_1.end);
            points.push(ang_cclCmb1_2.begin);
            points.push(ang_cclCmb1_2.end);
          }
        }
        points = Calc.sortAndUnique(points);
        for (var p = 1; p < points.length; p++) {
          p1 = points[p - 1];
          p2 = points[p];
          pm = p1 + (p2 - p1) / 2;
          ok = true;
          for (var a = 0; a < angles.length; a++) {
            var a1 = angles[a][0];
            var a2 = angles[a][1];
            if (!((a1.begin < pm && pm < a1.end) || (a2.begin < pm && pm < a2.end))) {
              ok = false;
              break;
            }
          }
          if (ok) {
            arcs.push(new Arc(cclCmbs[i].x, cclCmbs[i].y, cclCmbs[i].radius, new Angle(p1, p2)));
          }
        }
        // cclCmbs[i].setAngles(arcs);
      }

      ctx.stroke();


      var a = 0;
      var ex = 0;
      var ey = 0;
      arcs[a].moveToStart(ctx);
      [sx, sy] = arcs[a].startXY;
      ctx.beginPath();
      while (0 < arcs.length) {
        arcs[a].quasiDraw(ctx);
        [ex, ey] = arcs[a].endXY;
        arcs.splice(a, 1);

        if (Calc.arraysEqual([sx, sy], [ex, ey])) {
          ctx.closePath();
          ctx.stroke();
        }

        for (var i = 0; i < arcs.length; i++) {
          console.debug(arcs[i].startXY);
          console.debug([ex, ey]);
          if (Calc.arraysEqual(arcs[i].startXY, [ex, ey])) {
            a = i;
          }
        }
      }

      // for (var i = 0; i < arcs.length; i++) {

      //   // if (!arcs[i].isCircle)
      //   //   ctx.lineTo(this.startX, this.startY);

      // }

      // cclCmbs[i].clip(ctx);

      ctx.fillStyle = "#FFDDDD";
      ctx.fill();
      ctx.stroke();

      ctx.restore();

      window.requestAnimationFrame(draw);
    }

    var mtt = new MouseTouchTracker(canvas,
      function (evtType, x, y) {                         // callback 
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        switch (evtType) {

          case 'down':
            startX = x;
            startY = y;
            for (var i = 0; i < cclCmbs.length; i++)
              cclCmbs[i].startDrugIfPointIsInside(x, y);
            break;

          case 'up':
            for (var i = 0; i < cclCmbs.length; i++)
              cclCmbs[i].stopDrag();
            break;

          case 'move':
            var dx = x - startX;
            var dy = y - startY;
            startX = x;
            startY = y;

            for (var i = 0; i < cclCmbs.length; i++)
              cclCmbs[i].moveIfDragging(dx, dy);
            break;
        }
      }
    );

  </script>
</body>

</html>